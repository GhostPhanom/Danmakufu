let DialogXPart = 640 / 10;
let DialogYLine = 380;
let DialogPriority = 85;

/*
ObjDialog_MoveY(slot, targety, d) //Möglichen OffsetY bei der Spriteerstellung UNBEDINGT BEACHTEN
ObjDialog_SetPriority(slot, prio)
ObjDialog_SetAlpha(slot, alpha)
ObjDialog_ChangeDirection(slot, d)
ObjDialog_SetTexture(slot, texture)
ObjDialog_FadeinTexture(slot, texture, dir, a, scaleX, scaleY, offsetX, offsetY, d)
ObjDialog_FadeoutTexture(slot, d)
ObjDialog_MoveTexture(slot1, slot2, d)
*/

function ObjDialog_Activate
{
	let slots = [];
	let slotanzahl = 7;
	ascent(i in 1.. slotanzahl + 1)
	{
		slots = slots ~ [ObjDialog_CreateSlot(i)];
	}
	
	return slots; //Only needed for Debugging
}

function ObjDialog_CreateSlot(number)
{
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(obj, "");
	ObjSprite2D_SetDestCenter(obj);
	ObjRender_SetAlpha(obj, 0);
	ObjRender_SetPosition(obj, DialogXPart * (number + 1), DialogYLine, 0);
	
	SetCommonData("Slot " ~ IntToString(number) ~ "_Obj", obj);
	Obj_SetValue(obj, "BaseX", DialogXPart * (number + 1));
	Obj_SetValue(obj, "BaseY", DialogYLine);
	Obj_SetValue(obj, "OffsetX", 0);
	Obj_SetValue(obj, "OffsetY", 0);
	Obj_SetValue(obj, "ScaleX", 1);
	Obj_SetValue(obj, "ScaleY", 1);
	Obj_SetValue(obj, "Direction", 0); //1 for reversed
	Obj_SetValue(obj, "Alpha", 0);
	Obj_SetValue(obj, "Texture", "");
	Obj_SetValue(obj, "Priority", DialogPriority);
	Obj_SetValue(obj, "PriorityDiff", 0);
	RenderSlot(obj);
	
	task RenderSlot(obj)
	{
		while(!Obj_IsDeleted(obj))
		{
			if(Obj_GetValueD(obj, "Texture", "") != "" || Obj_GetValueD(obj, "Alpha", 0) != 0)
			{
				ObjPrim_SetTexture(obj, Obj_GetValueD(obj, "Texture", ""));
				ObjSprite2D_SetSourceRect(obj, 0, 1, GetTextureWidth(Obj_GetValueD(obj, "Texture", 0)), GetTextureHeight(Obj_GetValueD(obj, "Texture", 0)));
				ObjSprite2D_SetDestCenter(obj);
				ObjRender_SetPosition(obj, Obj_GetValueD(obj, "BaseX", 0) + Obj_GetValueD(obj, "OffsetX", 0), Obj_GetValueD(obj, "BaseY", 0) + Obj_GetValueD(obj, "OffsetY", 0), 0);
				ObjRender_SetAlpha(obj, Obj_GetValueD(obj, "Alpha", 128));
				ObjRender_SetScaleXYZ(obj, Obj_GetValueD(obj, "ScaleX", 1), Obj_GetValueD(obj, "ScaleY", 1), 0);
				Obj_SetRenderPriorityI(obj, Obj_GetValueD(obj, "Priority", 85) + Obj_GetValueD(obj, "PriorityDiff", 0));
				if(Obj_GetValueD(obj, "Direction", 0) == 0){ObjRender_SetAngleY(obj, 0);}
				if(Obj_GetValueD(obj, "Direction", 0) == 1){ObjRender_SetAngleY(obj, 180);} //2 is changeing to 0; 3 is changeing to 1
			}
			yield;
		}
	}
	return obj;
}

task ObjDialog_MoveY(slot, targety, d) //Möglichen OffsetY bei der Spriteerstellung UNBEDINGT BEACHTEN
{
	let obj = GetCommonData("Slot " ~ IntToString(slot) ~ "_Obj", 99999);
	if(obj == 99999){RaiseError("Slot not set! Slot Nr. " ~ IntToString(slot));}
	
	let y = Obj_GetValueD(obj, "OffsetY", 0);
	let party = (targety - y) / d;
	
	loop(d)
	{
		y += party;
		Obj_SetValue(obj, "OffsetY", y);
		yield;
	}
}

function ObjDialog_SetPriority(slot, prio) //Default is 0
{
	let obj = GetCommonData("Slot " ~ IntToString(slot) ~ "_Obj", 99999);
	if(obj == 99999){RaiseError("Slot not set! Slot Nr. " ~ IntToString(slot));}
	Obj_SetValue(obj, "PriorityDiff", prio);
}

task ObjDialog_ChangeDirection(slot, d)
{
	let obj = GetCommonData("Slot " ~ IntToString(slot) ~ "_Obj", 99999);
	if(obj == 99999){RaiseError("Slot not set! Slot Nr. " ~ IntToString(slot));}
	
	let spinpart = 180 / d;
	let spin = 0; 
	if(Obj_GetValueD(obj, "Direction", 0) == 1 || Obj_GetValueD(obj, "Direction", 0) == 3)
	{
		spin = 180; 
		Obj_SetValue(obj, "Direction", 2);//Set to be not 1 or 2 to stop RenderAngle Control from Rendertask 
	}
	Obj_SetValue(obj, "Direction", 3);//Set to be not 1 or 2 to stop RenderAngle Control from Rendertask 
	loop(d)
	{
		spin += spinpart;
		ObjRender_SetAngleY(obj, spin);
		yield;
	}
	if(spin == 360){Obj_SetValue(obj, "Direction", 0);}//Restore RenderAngle Control from Rendertask 
	else{Obj_SetValue(obj, "Direction", 1);}
}

function ObjDialog_SetAlpha(slot, alpha)
{
	let obj = GetCommonData("Slot " ~ IntToString(slot) ~ "_Obj", 99999);
	if(obj == 99999){RaiseError("Slot not set! Slot Nr. " ~ IntToString(slot));}
	Obj_SetValue(obj, "Alpha", alpha);
}

function ObjDialog_SetTexture(slot, texture)//dir direction Gedacht für Gesichtsausdruckwechsel
{
	let obj = GetCommonData("Slot " ~ IntToString(slot) ~ "_Obj", 99999);
	if(obj == 99999){RaiseError("Slot not set! Slot Nr. " ~ IntToString(slot));}
	LoadTexture(texture);
	ObjPrim_SetTexture(obj, texture);
	ObjSprite2D_SetSourceRect(obj, 0, 1, GetTextureWidth(texture), GetTextureHeight(texture));
	ObjSprite2D_SetDestCenter(obj);
	Obj_SetValue(obj, "Texture", texture);
}

task ObjDialog_FadeinTexture(slot, texture, dir, a, scaleX, scaleY, offsetX, offsetY, d) //dir direction, d duration, a alpha
{
	let obj = GetCommonData("Slot " ~ IntToString(slot) ~ "_Obj", 99999);
	if(obj == 99999){RaiseError("Slot not set! Slot Nr. " ~ IntToString(slot));}
	LoadTexture(texture);
	ObjPrim_SetTexture(obj, texture);
	ObjSprite2D_SetSourceRect(obj, 0, 1, GetTextureWidth(texture), GetTextureHeight(texture));
	ObjSprite2D_SetDestCenter(obj);
	Obj_SetValue(obj, "Texture", texture);
	
	ObjRender_SetScaleXYZ(obj, scaleX, scaleY, 0);
	Obj_SetValue(obj, "ScaleX", scaleX);
	Obj_SetValue(obj, "ScaleY", scaleY);
	
	Obj_SetValue(obj, "OffsetX", offsetX);
	Obj_SetValue(obj, "OffsetY", offsetY);
	Obj_SetValue(obj, "Direction", dir);
	
	let alpha = 0;
	let alphapart = a / d;
	//ObjRender_SetAlpha(obj, a);
	Obj_SetValue(obj, "Alpha", a);
	loop(d)
	{
		alpha += alphapart;
		ObjRender_SetAlpha(obj, alpha);
		Obj_SetValue(obj, "Alpha", alpha);
		yield;
	}
}

task ObjDialog_FadeoutTexture(slot, d) //dir direction, d duration
{
	let obj = GetCommonData("Slot " ~ IntToString(slot) ~ "_Obj", 99999);
	if(obj == 99999){RaiseError("Slot not set! Slot Nr. " ~ IntToString(slot));}
	
	let a = Obj_GetValueD(obj, "Alpha", 255);
	let alpha = a;
	let alphapart = a / d;
	//ObjRender_SetAlpha(obj, a);
	Obj_SetValue(obj, "Alpha", a);
	loop(d)
	{
		alpha -= alphapart;
		ObjRender_SetAlpha(obj, alpha);
		Obj_SetValue(obj, "Alpha", alpha);
		yield;
	}
}

task ObjDialog_MoveTexture(slot1, slot2, d)
{
	let obj1 = GetCommonData("Slot " ~ IntToString(slot1) ~ "_Obj", 99999);
	if(obj1 == 99999){RaiseError("Slot not set! Slot Nr. " ~ IntToString(slot1));}
	let obj2 = GetCommonData("Slot " ~ IntToString(slot2) ~ "_Obj", 99999);
	if(obj2 == 99999){RaiseError("Slot not set! Slot Nr. " ~ IntToString(slot2));}
	
	let baseX = Obj_GetValueD(obj1, "BaseX", 0);
	let baseY = Obj_GetValueD(obj1, "BaseY", 0);
	let offsetX = Obj_GetValueD(obj1, "OffsetX", 0);
	let offsetY = Obj_GetValueD(obj1, "OffsetY", 0);
	let scaleX = Obj_GetValueD(obj1, "ScaleX", 1);
	let scaleY = Obj_GetValueD(obj1, "ScaleY", 1);
	let direction = Obj_GetValueD(obj1, "Direction", 0); //1 for reversed; 2 is changeing to 0; 3 is changeing to 1
	if(direction == 2){direction = 0;}
	if(direction == 3){direction = 1;}
	let alpha = Obj_GetValueD(obj1, "Alpha", 0);
	let texture = Obj_GetValueD(obj1, "Texture", "");
	let priority = Obj_GetValueD(obj1, "Priority", DialogPriority);
	let prioritydiff = Obj_GetValueD(obj1, "PriorityDiff", 0);
	
	Obj_SetValue(obj1, "OffsetX", 0);//Zurücksetzen von Ursprungslot
	Obj_SetValue(obj1, "OffsetY", 0);
	Obj_SetValue(obj1, "ScaleX", 1);
	Obj_SetValue(obj1, "ScaleY", 1);
	Obj_SetValue(obj1, "Direction", 0); //1 for reversed
	Obj_SetValue(obj1, "Alpha", 0);
	//Obj_SetValue(obj1, "Texture", ""); //Für den If Check in der Render Routine
	Obj_SetValue(obj1, "Priority", DialogPriority);
	Obj_SetValue(obj1, "PriorityDiff", 0);
	
	let obj = ObjPrim_Create(OBJ_SPRITE_2D);
	LoadTexture(texture);
	ObjPrim_SetTexture(obj, texture);
	ObjSprite2D_SetSourceRect(obj, 0, 1, GetTextureWidth(texture), GetTextureHeight(texture));
	ObjSprite2D_SetDestCenter(obj);
	ObjRender_SetScaleXYZ(obj, scaleX, scaleY, 0);
	Obj_SetRenderPriorityI(obj, priority + prioritydiff);
	ObjRender_SetAlpha(obj, alpha);
	if(direction == 0){ObjRender_SetAngleY(obj, 0);}
	else{ObjRender_SetAngleY(obj, 180);}
	
	let baseX2 = Obj_GetValueD(obj2, "BaseX", 0);
	let baseY2 = Obj_GetValueD(obj2, "BaseY", 0);
	let posX1 = baseX + offsetX;
	let posY1 = baseY + offsetY;
	let posX2 = baseX2; //offsetX wird bei baseX2 laut Design zurückgesetzt ;offset2 wird zurückgesetzt
	let posY2 = baseY2 + offsetY;
	let partX = (posX2 - posX1) / d;
	let partY = (posY2 - posY1) / d;
	
	loop(d)
	{
		posX1 += partX;
		posY1 += partY;
		ObjRender_SetPosition(obj, posX1, posY1, 0);
		yield;
	}
	
	Obj_SetValue(obj1, "Texture", "");//Für den If Check in der Render Routine
	
	//Teil hierdrunter ist um einen 1 Frame langen und unschönen Übergang zu überbrücken
	LoadTexture(texture);
	ObjPrim_SetTexture(obj2, texture);
	ObjSprite2D_SetSourceRect(obj2, 0, 1, GetTextureWidth(texture), GetTextureHeight(texture));
	ObjSprite2D_SetDestCenter(obj2);
	ObjRender_SetScaleXYZ(obj2, scaleX, scaleY, 0);
	ObjRender_SetAlpha(obj2, alpha);
	ObjRender_SetPosition(obj2, posX1, posY1, 0);
	
	Obj_SetValue(obj2, "OffsetX", 0);
	Obj_SetValue(obj2, "OffsetY", offsetY);
	Obj_SetValue(obj2, "ScaleX", scaleX);
	Obj_SetValue(obj2, "ScaleY", scaleY);
	Obj_SetValue(obj2, "Direction", direction); //1 for reversed
	Obj_SetValue(obj2, "Alpha", alpha);
	Obj_SetValue(obj2, "Texture", texture);
	Obj_SetValue(obj2, "Priority", priority );
	Obj_SetValue(obj2, "PriorityDiff", prioritydiff);
	
	Obj_Delete(obj);
}